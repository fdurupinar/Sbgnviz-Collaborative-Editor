<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">collaborative-app/js/modelManager.js | Sbgnviz-Collaborative-Editor</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js">js</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/clientSideSocketListener.js~ClientSideSocketListener.html">ClientSideSocketListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/modelManager.js~ModelManager.html">ModelManager</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-merger">js/merger</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/merger/json-merger.js~JsonMerger.html">JsonMerger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/merger/model-merge-functions.js~ModelMergeFunctions.html">ModelMergeFunctions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/merger/rephrase-handler.js~RephraseHandler.html">RephraseHandler</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-newt-functions">js/newt-functions</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-editorlistener">editorlistener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PathsBetweenQueryView">PathsBetweenQueryView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PathsByURIQueryView">PathsByURIQueryView</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-oncoprint">js/oncoprint</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/oncoprint/oncoprint-handler.js~OncoprintHandler.html">OncoprintHandler</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-reach-functions">js/reach-functions</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-idxCardinfo">idxCardinfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-idxCardToJson">idxCardToJson</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-visual-manipulation">js/visual-manipulation</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/collaborative-app/js/visual-manipulation/vis-handler.js~VisHandler.html">VisHandler</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">collaborative-app/js/modelManager.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Author: Funda Durupinar Babur &lt;f.durupinar@gmail.com&gt;
 * Shared model handling operations.
 * Clients call these commands to update the model
 * Each room (docId) has one modelManager associated with it
 *
 **/


class ModelManager{

    /**
     *
     * @param {Object} model  shared model
     * @param {string} docId  room id/unique document id
     */
    constructor(model, docId){
        /**
         * @public
         */
        this.model = model;
        this.docId = docId;
    }

    /**
     *
     * @returns {Object} shared model including all model history
     */
    getModel() {
        return this.model;
    }

    /**
     *
     * @returns {Object} the model for this specific document
     */
    getPageDoc(){
        return this.model.get(&apos;documents.&apos; + this.docId);
    }

    /**
     * Adds an image to the model
     * @param {Object} data
     * @param {string} user
     * @param {boolean} noHistUpdate whether this operation will be recorded in history
     */
    addImage(data, user, noHistUpdate) {
        let self = this;
        let images = this.model.get(&apos;documents.&apos; + this.docId + &apos;.images&apos;);
        if(images) {
            for (let i = 0; i &lt; images.length; i++){
                if(images[i].tabIndex === data.tabIndex) { //overwrite
                    images[i] = data;
                    if (!noHistUpdate)
                        this.updateHistory({opName: &apos;overwrite&apos;, opTarget: &apos;image&apos;, opAttr: data.fileName});

                    //overwrite images
                    self.model.set(&apos;documents.&apos; + self.docId + &apos;.images&apos;, images);
                    return;
                }
            }
        }

        //if no such tab exists, insert a new tab
        this.model.pass({user: user}).push(&apos;documents.&apos; + this.docId + &apos;.images&apos;, data);

        if (!noHistUpdate)
            this.updateHistory({opName: &apos;add&apos;, opTarget: &apos;image&apos;, opAttr: data.fileName});
    }

    /**
     * Returns an array of images stored in the model
     * @returns {Array} images array
     */
    getImages(){
        return this.model.get(&apos;documents.&apos; + this.docId + &apos;.images&apos;);
    }

    /**
     * Sets user name for userId
     * @param {string} userId
     * @param {string} userName
     */
    setName (userId, userName) {
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId +&apos;.name&apos;, userName);
    }

    /**
     * Sets if user with userId is currently typing
     * @param {string} userId
     * @param {boolean} val
     */
    setUserTyping(userId, val){
        this.model.pass({user:&quot;me&quot;}).set(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId +&apos;.isTyping&apos;, val);
    }

    /**
     * Returns userName for userId
     * @param {string} userId
     * @returns {string} userName
     */
    getName (userId) {
        return this.model.get(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId + &apos;.name&apos;);
    }

    /***
     * Sets the color code of the user with userId
     * @param {string} userId id of the user we want to change color of
     * @param {string} color
     */
    setColorCode(userId, color){
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId +&apos;.colorCode&apos;, color);
    }

    /***
     * Randomly assigns a color to the user with userId
     * @param {string} userId of the user we want to change color of
     */
    changeColorCode(userId){
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId +&apos;.colorCode&apos;, getNewColor());
    }



    /***
     * @returns {Array} Active users in the room
     */
    getUserIds(){
        return this.model.get(&apos;documents.&apos; + this.docId + &apos;.userIds&apos;);
    }

    /***
     * Adds an active userId to the document and updates &apos;users&apos; info
     * @param {string} userId
     * @param {string} userName
     * @param {string} colorCode
     */
    addUser(userId, userName, colorCode){
        let userIds = this.model.get(&apos;documents.&apos; + this.docId + &apos;.userIds&apos;);

        if(!userIds || userIds.indexOf(userId) &lt; 0) //user not in the list
            this.model.at(&apos;documents.&apos; + this.docId + &apos;.userIds&apos;).push(userId);


        let usersPath = this.model.at(&apos;documents.&apos; + this.docId + &apos;.users&apos;);

        if(!usersPath.get(userId)){
            if(!userName) {
                //find maximum userId index
                let users = usersPath.get();
                let maxId = 0;
                for(let att in users){
                    if(users.hasOwnProperty(att)){
                        if(users[att].name &amp;&amp; users[att].name.indexOf(&apos;User&apos;) &gt; -1) {
                            let idNumber = Number(users[att].name.slice(4));
                            if (idNumber &gt; maxId)
                                maxId = idNumber;
                        }
                    }
                }

                userName = &quot;User&quot; + (maxId +1);
            }
            if(!colorCode)
                colorCode = getNewColor();

            this.setName(userId, userName);
            this.setUserTyping(userId, false);
            this.setColorCode(userId, colorCode);
        }
    }

    /**
     * Deletes all the users
     */
    deleteAllUsers(){
        let self = this;
        let userIds = this.model.get(&apos;documents.&apos; + this.docId + &apos;.userIds&apos;);
        for(let i = userIds.length - 1; i&gt;=0; i--){
            self.deleteUserId(userIds[i]);
        }
    }

    /**
     * Deletes user with userId
     * @param {string} userId
     */
    deleteUserId(userId){
        let self = this;

        let userIds = this.model.get(&apos;documents.&apos; + this.docId + &apos;.userIds&apos;);
        for(let i = 0; i &lt; userIds.length; i++){
            if(userIds[i] === userId ){
                self.model.remove(&apos;documents.&apos; + self.docId + &apos;.userIds&apos;, i) ; //remove from the index
            }
        }
    }

    /**
     * Updates layout properties
     * @param {Object} properties
     */
    setLayoutProperties(properties){
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.layoutProperties&apos;, properties);
    }

    /**
     *
     * @returns {Object} layoutProperties
     */
    getLayoutProperties(){
        return this.model.get(&apos;documents.&apos; + this.docId + &apos;.layoutProperties&apos;);
    }


    /**
     * Updates the oncoprint data
     * @param {Object} oncoprintVal
     */
    setOncoprint(oncoprintVal){
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.oncoprint&apos;, oncoprintVal);
    }

    /**
     *
     * @returns {Object} oncoprint
     */
    getOncoprint(){
        return this.model.get(&apos;documents.&apos; + this.docId + &apos;.oncoprint&apos;);
    }

    /***
     *
     * @param {Object} cmd  {opName, opTarget,  elType, elId, opAttr,param, prevParam}
     * opName: set, load, open, add, select, unselect
     * opTarget: element, element group,  model, sample,
         * elType: node, edge
         * opAttr: highlightColor, lineColor, borderColor etc.
         */

    updateHistory (cmd) {
        let command = {
            date: new Date,
            opName: cmd.opName,
            opTarget: cmd.opTarget,
            elType: cmd.elType,
            opAttr: cmd.opAttr,
            elId: cmd.elId,
            cyId: cmd.cyId,
            param: cmd.param,
            prevParam: cmd.prevParam
        };

        if (cmd != null) {
            let ind = this.model.push(&apos;documents.&apos; + this.docId + &apos;.history&apos;, command) - 1;
            this.model.set(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;, ind);
        }
    }

    /**
     *
     * @returns {string} Name of the latest command
     */
    getLastCommandName(){
        let undoIndex = this.model.get(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;);
        let cmd = this.model.get(&apos;documents.&apos; + this.docId + &apos;.history.&apos; + undoIndex);

        return cmd.opName;
    }


    /**
     *
     * @returns {boolean} if there are enough commands to undo
     */
    isUndoPossible() {
        return (this.model.get(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;) &gt; 0)
    }

    /**
     *
     * @returns {boolean} If we are not already at the latest command
     */
    isRedoPossible() {
        return (this.model.get(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;) + 1 &lt; this.model.get(&apos;documents.&apos; + this.docId + &apos;.history&apos;).length)
    }

    /**
     * Undo latest command
     */
    undoCommand() {
        let undoInd = this.model.get(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;);
        let cmd = this.model.get(&apos;documents.&apos; + this.docId + &apos;.history.&apos; + undoInd); // cmd: opName, opTarget, opAttr, elId, param


        if (cmd.opName == &quot;set&quot;) {
            if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;node&quot;)
                this.changeModelNodeAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.prevParam, null); //user is null to enable updating in the editor

            else if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;edge&quot;)
                this.changeModelEdgeAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.prevParam, null);
            else if (cmd.opTarget == &quot;element group&quot;)
                this.changeModelElementGroupAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.prevParam, null);

        }
        else if (cmd.opName == &quot;add&quot; || cmd.opName ===&quot;restore&quot;) {
            if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;node&quot;)
                this.deleteModelNode(cmd.elId, cmd.cyId );
            else if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;edge&quot;)
                this.deleteModelEdge(cmd.elId, cmd.cyId);
            else if (cmd.opTarget == &quot;compound&quot;)
                this.removeModelCompound(cmd.elId, cmd.cyId, cmd.param.childrenList, cmd.prevParam);
        }
        else if (cmd.opName == &quot;delete&quot;) {
            if (cmd.opTarget == &quot;element&quot;)
                this.restoreModelElement(cmd.elType, cmd.elId, cmd.cyId, cmd.prevParam);
            else if (cmd.opTarget == &quot;element group&quot;){

                this.restoreModelElementGroup(cmd.elId, cmd.cyId, cmd.prevParam);
            }
            else if (cmd.opTarget == &quot;compound&quot;)
                this.addModelCompound(cmd.elId, cmd.cyId, cmd.prevParam.compoundAtts, cmd.prevParam.childrenList, cmd.prevParam.paramList);

        }
        // else if(cmd.opName === &quot;update&quot;){ //properties
        //     if(cmd.opTarget.indexOf(&apos;general&apos;) &gt;= 0)
        //         this.updateGeneralProperties(cmd.prevParam);
        //     else if(cmd.opTarget.indexOf(&apos;layout&apos;) &gt;= 0)
        //         this.updateLayoutProperties(cmd.prevParam);
        //     else if(cmd.opTarget.indexOf(&apos;grid&apos;) &gt;= 0)
        //         this.updateGridProperties(cmd.prevParam);
        //
        // }
        else if (cmd.opName == &quot;init&quot;) {
            this.newModel(cmd.cyId, null, true);
        }
        else if (cmd.opName == &quot;new&quot;) { //delete all
            this.restoreModel( cmd.prevParam, cmd.cyId);

        }
        else if (cmd.opName == &quot;merge&quot;) {
            this.newModel(cmd.cyId, null, true);
            this.restoreModel(cmd.prevParam, cmd.cyId);
        }

        undoInd = undoInd &gt; 0 ? undoInd - 1 : 0;
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;, undoInd);

    }

    /**
     * Redo latest command
     */
    redoCommand () {
        let undoInd = this.model.get(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;);
        let cmd = this.model.get(&apos;documents.&apos; + this.docId + &apos;.history.&apos; + (undoInd + 1)); // cmd: opName, opTarget, opAttr, elId, param


        if (cmd.opName == &quot;set&quot;) {
            if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;node&quot;)
                this.changeModelNodeAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.param, null); //user is null to enable updating in the editor
            else if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;edge&quot;)
                this.changeModelEdgeAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.param, null);
            else if (cmd.opTarget == &quot;element group&quot;) {
                this.changeModelElementGroupAttribute(cmd.opAttr, cmd.elId, cmd.cyId, cmd.param, null);
            }
        }
        else if (cmd.opName == &quot;add&quot; ||cmd.opName == &quot;restore&quot;) {
            if (cmd.opTarget == &quot;element&quot;)
                this.restoreModelElement(cmd.elType, cmd.elId, cmd.cyId, cmd.param);
            else if (cmd.opTarget == &quot;compound&quot;)
                this.addModelCompound(cmd.elId, cmd.cyId, cmd.param.compoundAtts, cmd.param.childrenList, cmd.param.paramList);
        }
        else if (cmd.opName == &quot;delete&quot;) {
            if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;node&quot;)
                this.deleteModelNode(cmd.elId, cmd.cyId);
            else if (cmd.opTarget == &quot;element&quot; &amp;&amp; cmd.elType == &quot;edge&quot;)
                this.deleteModelEdge(cmd.elId, cmd.cyId);
            else if (cmd.opTarget == &quot;element group&quot;)
                this.deleteModelElementGroup(cmd.elId, cmd.cyId);
            else if (cmd.opTarget == &quot;compound&quot;)
                this.removeModelCompound(cmd.elId, cmd.cyId, cmd.param.childrenList, cmd.param);

        }
        // else if(cmd.opName === &quot;update&quot;){ //properties
        //     if(cmd.opTarget.indexOf(&apos;general&apos;) &gt;= 0)
        //         this.updateGeneralProperties(cmd.param);
        //     else if(cmd.opTarget.indexOf(&apos;layout&apos;) &gt;= 0)
        //         this.updateLayoutProperties(cmd.param);
        //     else if(cmd.opTarget.indexOf(&apos;grid&apos;) &gt;= 0)
        //         this.updateGridProperties(cmd.param);
        //
        // }
        else if (cmd.opName == &quot;init&quot;) {
            this.restoreModel(cmd.param, cmd.cyId );
        }
        else if (cmd.opName == &quot;new&quot;) { //delete all
            this.newModel(cmd.cyId );
        }
        else if (cmd.opName == &quot;merge&quot;) { //delete all
            this.restoreModel(cmd.param, cmd.cyId);
        }

        undoInd = undoInd &lt; this.model.get(&apos;documents.&apos; + this.docId + &apos;.history&apos;).length - 1 ? undoInd + 1 : this.model.get(&apos;documents.&apos; + this.docId + &apos;.history&apos;).length - 1;
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.undoIndex&apos;, undoInd);
    }


    /**
     * Notifies other users that a new tab has been opened
     * @param {Number} cyId Id of the tab that&apos;s closed
     * @param {string} user Parameter to test if the update comes from the same client
     */
    openCy(cyId, user){

        let cyPathStr = this.getModelCyPathStr(cyId);
        // this.model.pass({user: user}).set(&apos;documents.&apos; + this.docId + &apos;.newCy&apos;, cyId); //let others know
        this.model.pass({user:user}).set(cyPathStr + &apos;.cyId&apos;, cyId);
    }

    /**
     * Does not remove the cy, only notifies other users that a tab is closed
     * @param {Number} cyId Id of the tab that&apos;s closed
     * @param {string} user Parameter to test if the update comes from the same client
     */
    closeCy(cyId, user){

        this.model.pass({user: user}).set(&apos;documents.&apos; + this.docId + &apos;.closedCy&apos;, cyId);
    }


    /**
     * Returns Newt tab ids with different cytoscape views
     * @returns {Array} Newt tabs
     */
    getCyIds(){
        let cyList = this.model.get(&apos;documents.&apos; + this.docId + &apos;.cy&apos;);
        let cyIds = [];
        for(var att in cyList){
            if(cyList.hasOwnProperty(att))
                cyIds.push(att);
        }

        return cyIds;
    }

    /**
     * Returns path to the cytoscape view with cyId
     * @param {Number} cyId
     * @returns {string}
     */
    getModelCyPathStr(cyId){
        return &apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId ;
    }

    /**
     * Returns path to the node with id in the view with cyId
     * @param {string} id
     * @param {Number} cyId
     * @returns {string}
     */
    getModelNodePathStr(id, cyId){
        return &apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId +&apos;.nodes.&apos; + id;
    }

    /**
     * Returns the node with id in the view with cyId
     * @param {string} id
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelNode(id, cyId) {
        let nodePath = this.model.at(this.getModelNodePathStr(id, cyId));
        return nodePath.get();
    }

    /**
     * Returns all the nodes in the view with cyId as an array
     * @param {Number} cyId
     * @returns {Array}
     */
    getModelNodesArr(cyId){
        let nodes = this.model.get(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId + &apos;.nodes&apos;);
        let nodeArr = [];
        for(var att in nodes){
            if(nodes.hasOwnProperty(att))
                nodeArr.push(nodes[att]);
        }

        return nodeArr;
    }

    /**
     * Returns all the nodes in the view with cyId as an object
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelNodes(cyId) {
        let nodes = this.model.get(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId + &apos;.nodes&apos;);
        return nodes;
    }

    /**
     * Tests if node with nodeId is in the view with cyId
     * @param {Number} cyId
     * @param {string} nodeId
     * @returns {boolean}
     */
    isNodeInModel(cyId, nodeId){
        let nodesArr = this.getModelNodesArr(cyId);

        for(let i = 0; i &lt; nodesArr.length; i++){
            if(nodesArr[i].id == nodeId)
                return true;
        }

        return false;
    }

    /**
     * Tests if edge with edgeId is in the view with cyId
     * @param {Number} cyId
     * @param {string} edgeId
     * @returns {boolean}
     */
    isEdgeInModel(cyId, edgeId) {
        let edgesArr = this.getModelEdgesArr(cyId);

        for (let i = 0; i &lt; edgesArr.length; i++) {
            if (edgesArr[i].id == edgeId)
                return true;
        }

        return false;
    }

    /**
     * Returns path to the edge with id in the view with cyId
     * @param {string} id
     * @param {Number} cyId
     * @returns {string}
     */
    getModelEdgePathStr(id, cyId){
        return &apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId +&apos;.edges.&apos; + id;
    }

    /**
     * Returns the edge with id in the view with cyId
     * @param {string} id
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelEdge (id, cyId) {
        let edgePath = this.model.at(this.getModelEdgePathStr(id, cyId));
        return edgePath.get();
    }

    /**
     * Returns all the edges in the view with cyId as an array
     * @param {Number} cyId
     * @returns {Array}
     */
    getModelEdgesArr(cyId){
        let edges = this.model.get(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId +&apos;.edges&apos;);
        let edgeArr = [];
        for(var att in edges){
            if(edges.hasOwnProperty(att))
                edgeArr.push(edges[att]);
        }

        return edgeArr;
    }

    /**
     * Highlights the cytoscape node with the color of the selecting user
     * @param {Object} node cytoscape node
     * @param {Number} cyId
     * @param {string} userId User who made the selection
     * @param {string} user parameter to test if the update comes from the same client
     * @returns {string} success or failure message
     */
    selectModelNode (node, cyId, userId, user) {

        let nodePathStr = this.getModelNodePathStr(node.id(), cyId);
        let nodePath = this.model.at(nodePathStr);
        if (nodePath.get() == null)
            return &quot;Node id not found&quot;;

        let userPath = this.model.at(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId);

        this.model.pass({user: user}).set(nodePathStr + &apos;.highlightColor&apos;, userPath.get(&apos;colorCode&apos;));

        return &quot;success&quot;

    }


    /**
     * Highlights the cytoscape edge with the color of the selecting user
     * @param {Object} edge cytoscape edge
     * @param {Number} cyId
     * @param {string} userId User who made the selection
     * @param {string} user parameter to test if the update comes from the same client
     * @returns {string} success or failure message
     */
    selectModelEdge (edge, cyId, userId, user) {

        let edgePathStr = this.getModelEdgePathStr(edge.id(), cyId);
        let edgePath = this.model.at(edgePathStr);
        if (edgePath.get() == null)
            return &quot;Edge id not found&quot;;
        let userPath = this.model.at(&apos;documents.&apos; + this.docId + &apos;.users.&apos; + userId);
        this.model.pass({user: user}).set(edgePathStr + &apos;.highlightColor&apos;, userPath.get(&apos;colorCode&apos;));
        return &quot;success&quot;;

    }

    /**
     * Removes the highlight of the cytoscape node
     * @param {Object} node cytoscape node
     * @param {Number} cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @returns {string} success or failure message
     */
    unselectModelNode (node, cyId,  user) {

        let nodePathStr = this.getModelNodePathStr(node.id(), cyId);
        let nodePath = this.model.at(nodePathStr);

        if (nodePath.get() == null)
            return &quot;Node id not found&quot;;

        this.model.pass({user: user}).set(nodePathStr + &apos;.highlightColor&apos;, null);

        return &quot;success&quot;;
    }

    /**
     * Removes the highlight of the cytoscape edge
     * @param {Object} edge cytoscape edge
     * @param {Number} cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @returns {string} success or failure message
     */
    unselectModelEdge (edge,  cyId, user) {

        let edgePathStr = this.getModelEdgePathStr(edge.id(), cyId);
        let edgePath = this.model.at(edgePathStr);
        if (edgePath.get() == null)
            return &quot;Edge id not found&quot;;

        this.model.pass({user: user}).set(edgePathStr + &apos;.highlightColor&apos;, null);

        return &quot;success&quot;;


    }

    /***
     *
     * Adds node with given attributes
     * @param {string} nodeId
     * @param {Number} cyId
     * @param {Object} param {position:, data:}
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate whether this operation will be recorded in history
     * returns {string} success or failure message
     */

    addModelNode (nodeId, cyId, param, user, noHistUpdate) {
        let nodePathStr = this.getModelNodePathStr(nodeId, cyId);

        if (this.model.get(nodePathStr) != null)
            return &quot;Node cannot be duplicated&quot;;

        this.model.pass({user: user}).set(nodePathStr + &apos;.id&apos;, nodeId);
        this.model.pass({user: user}).set(nodePathStr + &apos;.data.id&apos;, nodeId);
        this.model.pass({user: user}).set(nodePathStr + &apos;.position&apos;, param.position);
        this.model.pass({user: user}).set(nodePathStr + &apos;.data&apos;, param.data);

        //adding the node in cytoscape
        this.model.pass({user: user}).set(nodePathStr+ &apos;.addedLater&apos;, true);



        if (!noHistUpdate)
        //We don&apos;t want all the attributes of the param to be printed
            this.updateHistory({
                opName: &apos;add&apos;,
                opTarget: &apos;element&apos;,
                elType: &apos;node&apos;,
                elId: nodeId,
                cyId: cyId,
                param: param

            });


        return &quot;success&quot;;

    }

    /***
     *
     * Adds edge with given attributes
     * @param {string} edgeId
     * @param {Number} cyId
     * @param {Object} param {position:, data:}
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate whether this operation will be recorded in history
     * returns {string} success or failure message
     */
    addModelEdge (edgeId, cyId, param, user, noHistUpdate) {

        let edgePathStr = this.getModelEdgePathStr(edgeId, cyId);
        if (this.model.get(edgePathStr) != null)
            return &quot;Edge cannot be duplicated&quot;;

        this.model.pass({user: user}).set(edgePathStr+ &apos;.data.id&apos;, edgeId);
        this.model.pass({user: user}).set(edgePathStr+ &apos;.data&apos;, param.data);


        //adding the edge...other operations should be called after this
        this.model.pass({user: user}).set(edgePathStr + &apos;.addedLater&apos;, true);


        if (!noHistUpdate)
            this.updateHistory({
                opName: &apos;add&apos;,
                opTarget: &apos;element&apos;,
                elType: &apos;edge&apos;,
                elId: edgeId,
                cyId: cyId,
                param: param

            });

        return &quot;success&quot;;

    }

    /***
     * Adds a new compound with given attributes
     * @param {string} compoundId New compound&apos;s id
     * @param {Number} cyId
     * @param {Object} compoundAtts Attributes for new compound
     * @type {Object} compoundAtts Attributes for new compound
     * @property {string} compoundAtts.position
     * @property {string}compoundAtts.data
     * @param {Array} elList Children list
     * @property {string} elList[i].id
     * @property {string} elList[i].isNode
     * @param {Array} paramList Children&apos;s data attributes
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */

    addModelCompound (compoundId, cyId, compoundAtts, elList, paramList, user, noHistUpdate) {

        let prevParentList = [];
        paramList.forEach(function(param){
            // prevParentList.push(paramList.parent);
            prevParentList.push(param.parent);
        });

        this.addModelNode(compoundId, cyId, compoundAtts, user, true);

        this.changeModelElementGroupAttribute(&quot;data&quot;, elList, cyId, paramList,  user, true);



        if (!noHistUpdate)
            this.updateHistory({
                opName: &apos;add&apos;,
                opTarget: &apos;compound&apos;,
                elId: compoundId,
                cyId: cyId,
                param: {paramList: paramList, childrenList: elList, compoundAtts: compoundAtts},
                prevParam:  prevParentList //TODO
            });

    }


    /***
     * Removes compound and changes children&apos;s parents to their old parents
     * @param {string} compoundId  New compound&apos;s id
     * @param {Number} cyId
     * @param {Object} childrenList Children list as {id:, isNode:}
     * @param {Array} prevParentList Children&apos;s previous parents
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */

    removeModelCompound (compoundId, cyId, childrenList, prevParentList, user, noHistUpdate) {
        let self = this;

        let nodePath = this.model.at(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId + &apos;.nodes.&apos; + compoundId);

        let compoundAtts = {
            id: compoundId,
            class: nodePath.get(&apos;data.class&apos;),
            x: nodePath.get(&apos;position.x&apos;),
            y: nodePath.get(&apos;position.y&apos;)

        };

        let paramList = [];
        childrenList.forEach(function(child){
            let data = self.model.get(self.getModelNodePathStr(child.id, cyId));
            paramList.push(data);
        });

        //isolate the compound first, then delete
        this.changeModelElementGroupAttribute(&quot;data.parent&quot;, childrenList, cyId, prevParentList,   user, true);
        this.deleteModelNode(compoundId, cyId, user, true);

        if (!noHistUpdate)
            this.updateHistory({
                opName: &apos;delete&apos;,
                opTarget: &apos;compound&apos;,
                elId: compoundId,
                cyId: cyId,
                prevParam: {childrenList: childrenList, compoundAtts: compoundAtts, paramList: paramList},
                param: prevParentList
            });

    }


    /**
     *
     * @param {string} attStr Attribute name in the model
     * @param {Array} elList Nodes and/or edges to change attributes
     * @param cyId
     * @param {Array} paramList New parameter values
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     * @returns {string}
     */
    changeModelElementGroupAttribute (attStr, elList, cyId, paramList,   user, noHistUpdate) { //historyData){
        let self = this;
        let prevParamList = [];

        if (!noHistUpdate) {

            elList.forEach(function (el) {

                let prevAttVal;
                if (el.isNode)
                    prevAttVal = self.model.get(self.getModelNodePathStr(el.id, cyId) + &apos;.&apos; + attStr);
                else
                    prevAttVal = self.model.get(self.getModelEdgePathStr(el.id, cyId) + &apos;.&apos; + attStr);


                prevParamList.push(prevAttVal);
            });


            this.updateHistory({
                opName: &apos;set&apos;,
                opTarget: &apos;element group&apos;,
                elId: elList,
                cyId: cyId,
                opAttr: attStr,
                param: paramList,
                prevParam: prevParamList
            });

        }

        let ind = 0;
        elList.forEach(function (el) {
            let currAttVal = paramList[ind++];

            if (el.isNode)
                self.changeModelNodeAttribute(attStr, el.id, cyId, currAttVal, user, true); //don&apos;t update individual histories
            else
                self.changeModelEdgeAttribute(attStr, el.id, cyId, currAttVal, user, true);

        });

        return &quot;success&quot;;

    }

    /**
     * Returns the node&apos;s attribute value
     * @param {string} attStr
     * @param {string} nodeId
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelNodeAttribute(attStr, nodeId, cyId){
        let nodePathStr = this.getModelNodePathStr(nodeId, cyId);
        let nodePath = this.model.at(nodePathStr);

        return nodePath.get(attStr);
    }

    /**
     * Returns the edge&apos;s attribute value
     * @param {string} attStr
     * @param {string} edgeId
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelEdgeAttribute(attStr, edgeId, cyId){

        if(!this.isEdgeInModel(cyId, edgeId))
            return;

        let edgePathStr = this.getModelEdgePathStr(edgeId, cyId);
        let edgePath = this.model.at(edgePathStr);

        return edgePath.get(attStr);
    }

    /**
     * @param {string} attStr attribute name in the model
     * @param {string} nodeId
     * @param {Number} cyId
     * @param {Object} attVal new value to assign
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate whether this operation will be recorded in history
     * @returns {string} success or failure
     */

    changeModelNodeAttribute (attStr, nodeId, cyId, attVal, user, noHistUpdate) {

        if(!this.isNodeInModel(cyId, nodeId))
            return;

        let nodePathStr = this.getModelNodePathStr(nodeId, cyId);
        let nodePath = this.model.at(nodePathStr);


        let prevAttVal = nodePath.get(attStr);

        if(attStr === &quot;width&quot;) //as we read this directly from cy.data
            attStr = &quot;borderWidth&quot;;


        nodePath.pass({user: user}).set(attStr, attVal);

        if (attStr == &quot;expandCollapseStatus&quot;) {
            if (attVal == &quot;expand&quot;)
                prevAttVal = &quot;collapse&quot;;
            else //if null or collapse
                prevAttVal = &quot;expand&quot;;
        }

        if (attStr != &apos;interactionCount&apos;) {
            this.model.increment(nodePathStr +  &apos;.interactionCount&apos;, 1);

            if (!noHistUpdate) {

                this.updateHistory({
                    opName: &apos;set&apos;,
                    opTarget: &apos;element&apos;,
                    elType: &apos;node&apos;,
                    elId: nodeId,
                    cyId: cyId,
                    opAttr: attStr,
                    param: attVal,
                    prevParam: prevAttVal
                });
            }
        }

        return &quot;success&quot;;

    }

    /**
     * @param {string} attStr attribute name in the model
     * @param {string} edgeId
     * @param {Number} cyId
     * @param {Object} attVal new value to assign
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate whether this operation will be recorded in history
     * @returns {string} success or failure
     */
    changeModelEdgeAttribute (attStr, edgeId, cyId, attVal, user, noHistUpdate) {
        let edgePathStr = this.getModelEdgePathStr(edgeId, cyId);
        let edgePath = this.model.at(edgePathStr);
        let prevAttVal = edgePath.get(attStr);
        edgePath.pass({user: user}).set(attStr, attVal);


        let sourceId = edgePath.get(&apos;source&apos;);
        let targetId = edgePath.get(&apos;target&apos;);

        if (sourceId){
            let sourcePathStr = this.getModelNodePathStr(sourceId, cyId);
            this.model.increment(sourcePathStr +  &apos;.interactionCount&apos;, 1);
        }

        if (targetId){
            let targetPathStr = this.getModelNodePathStr(targetId, cyId);
            this.model.increment(targetPathStr +  &apos;.interactionCount&apos;, 1);
        }


        if (!noHistUpdate) {

            this.updateHistory({
                opName: &apos;set&apos;,
                opTarget: &apos;element&apos;,
                elType: &apos;edge&apos;,
                elId: edgeId,
                cyId: cyId,
                opAttr: attStr,
                param: attVal,
                prevParam: prevAttVal
            });

        }

        return &quot;success&quot;;
    }


    /**
     * Delete node from the shared model
     * @param {string} nodeId Node id to delete
     * @param {Number} cyId Cy id to delete node from
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     * @returns {string} Success or failure

     */
    deleteModelNode (nodeId, cyId, user, noHistUpdate) {
        let nodePathStr = this.getModelNodePathStr(nodeId, cyId);
        let nodePath = this.model.at(nodePathStr);

        if (nodePath.get() == null)
            return &quot;Node id not found&quot;;

        if (!noHistUpdate) {


            let prevParam = nodePath.get();


            this.updateHistory({
                opName: &apos;delete&apos;,
                opTarget: &apos;element&apos;,
                elType: &apos;node&apos;,
                elId: nodeId,
                cyId: cyId,
                prevParam: prevParam

            });

        }

        this.model.pass({user: user}).del(nodePathStr);

        return &quot;success&quot;;

    }

    /**
     * Delete edge from the shared model
     * @param {string} edgeId  Edge id to delete
     * @param {Number} cyId Cy id to delete edge from
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     * @returns {string} Success or failure
     */
    deleteModelEdge (edgeId, cyId, user, noHistUpdate) {
        let edgePathStr = this.getModelEdgePathStr(edgeId, cyId);
        let edgePath = this.model.at(edgePathStr);
        if (edgePath.get() == null)
            return &quot;Edge id not found&quot;;


        if (!noHistUpdate) {

            let prevParam = edgePath.get();

            this.updateHistory({
                opName: &apos;delete&apos;,
                opTarget: &apos;element&apos;,
                elType: &apos;edge&apos;,
                elId: edgeId,
                cyId: cyId,
                prevParam: prevParam
            });

        }

        this.model.pass({user: user}).del(edgePathStr);

        return &quot;success&quot;;

    }


    /**
     * Delete the elements in selectedEles group
     * @param {Array} selectedEles
     * @param cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     * @returns {string} Success or failure
     */
    deleteModelElementGroup (selectedEles, cyId, user, noHistUpdate) {
        let prevParamsNodes = [];
        let prevParamsEdges = [];
        let self = this;


        if(selectedEles.edges!= null){
            selectedEles.edges.forEach(function (edge) {
                let edgePathStr = self.getModelEdgePathStr(edge.id, cyId);
                let edgePath = self.model.at(edgePathStr);
                prevParamsEdges.push(edgePath.get());
            });


            selectedEles.edges.forEach(function (edge) {
                self.deleteModelEdge(edge.id, cyId, user, true); //will not update children history
            });
        }

        if(selectedEles.nodes!= null) {
            selectedEles.nodes.forEach(function (node) {
                let nodePathStr = self.getModelNodePathStr(node.id, cyId);
                let nodePath = self.model.at(nodePathStr);

                prevParamsNodes.push(nodePath.get());
            });


            selectedEles.nodes.forEach(function (node) {
                self.deleteModelNode(node.id, cyId, user, true); //will not update children history
            });
        }
        if (!noHistUpdate)
            this.updateHistory({
                opName: &apos;delete&apos;,
                opTarget: &apos;element group&apos;,
                elId: selectedEles,
                cyId: cyId,
                prevParam: {nodes: prevParamsNodes, edges: prevParamsEdges}
            });


    }

    /**
     * Restores the deleted elements into the shared model
     * @param {Array} elList Elements to restore
     * @param {Number} cyId
     * @param {Object} param
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    restoreModelElementGroup (elList, cyId, param, user, noHistUpdate) {
        let self = this;
        //Restore nodes first


        for (let i = 0; i &lt; elList.nodes.length; i++) {
            self.restoreModelNode(elList.nodes[i].id, cyId, param.nodes[i], user, noHistUpdate);
        }

        //restore edges later
        for (let i = 0; i &lt; elList.edges.length; i++) {
            self.restoreModelEdge(elList.edges[i].id, cyId,  param.edges[i], user, noHistUpdate);
        }

        //change parents after adding them all
        for (let i = 0; i &lt; elList.nodes.length; i++) {
            self.changeModelNodeAttribute(&apos;parent&apos;, elList.nodes[i].id, cyId, param.nodes[i].parent, null, noHistUpdate);
        }



        if (!noHistUpdate)
            self.updateHistory({
                opName: &apos;restore&apos;,
                opTarget: &apos;element group&apos;,
                elId: elList,
                cyId: cyId,
                param: param

            });
    }


    /**
     * Restores the deleted node into the shared model
     * @param {string} nodeId Node to restore
     * @param {Number} cyId
     * @param {Object} param Node data and position
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    restoreModelNode (nodeId, cyId, param, user, noHistUpdate) {

        //param is the previous node data
        //history is updated as restore command
        this.addModelNode(nodeId, cyId, param, user, true);

        //No need to init -- data and position are updated in the next steps

        if (!noHistUpdate)
            this.updateHistory({opName: &apos;restore&apos;, opTarget: &apos;element&apos;, elType: &apos;node&apos;, elId: nodeId, cyId: cyId, param:param});
    }


    /**
     * Restores the deleted edge into the shared model
     * @param {string} edgeId Edge to restore
     * @param {Number} cyId
     * @param {Object} param Edge data
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    restoreModelEdge (edgeId, cyId, param, user, noHistUpdate) {
        //param is the previous edge data
        //history is updated as restore command
        this.addModelEdge(edgeId, cyId, param, user, true);
        //No need to init -- data and position are updated in the next steps


        if (!noHistUpdate)
            this.updateHistory({opName: &apos;restore&apos;, opTarget: &apos;element&apos;, elType: &apos;edge&apos;, elId: edgeId, cyId: cyId, param:param});
    }


    /**
     * Restores the deleted element into the shared model
     * @param {string} elType &quot;node&quot; or &quot;edge&quot;
     * @param {string} elId Element to restore
     * @param {Number} cyId
     * @param {Object} param Element data
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    restoreModelElement (elType, elId, cyId, param, user, noHistUpdate) {

        if (elType == &quot;node&quot;)
            this.restoreModelNode(elId, cyId, param, user, noHistUpdate);
        else
            this.restoreModelEdge(elId, cyId, param, user, noHistUpdate);


    }


    /**
     * This function is used to undo newModel and redo initModel
     * @param {Object} modelCy : nodes and edges to be restored
     * @param {Number} cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    restoreModel (modelCy, cyId, user, noHistUpdate) {
        let cyPathStr = this.getModelCyPathStr(cyId);
        let prevParam = this.model.get(cyPathStr);
        this.model.pass({user: user}).set(cyPathStr , modelCy);


        // this.setSampleInd(-1, null, true); //to get a new container

        if (!noHistUpdate)
            this.updateHistory({opName: &apos;restore&apos;, prevParam: prevParam, param: modelCy, cyId: cyId, opTarget: &apos;model&apos;});

    }


    /**
     * Deletes the model and everything in it
     * Should be called before loading a new graph to prevent id confusion
     * @param {Number} cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    newModel (cyId, user, noHistUpdate) {

        let self = this;
        let cyPathStr = this.getModelCyPathStr(cyId);
        let prevModelCy = this.model.get(cyPathStr);


        if (!noHistUpdate)
            this.updateHistory({opName: &apos;new&apos;, prevParam: prevModelCy, cyId: cyId, opTarget: &apos;model&apos;});

        let edges = this.model.get(cyPathStr +&apos;.edges&apos;);
        let nodes = this.model.get(cyPathStr +&apos;.nodes&apos;);


        for (let att in edges) {
            if (edges.hasOwnProperty(att)) {
                self.deleteModelEdge(edges[att].id, cyId, user, true);
            }
        }

        for (let att in nodes) {
            if (nodes.hasOwnProperty(att)) {
                self.deleteModelNode(nodes[att].id, cyId, user, true);
            }
        }

        this.model.pass({user: user}).del(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId +&apos;.edges&apos;);
        this.model.pass({user: user}).del(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId +&apos;.nodes&apos;);

    }



    /**
     * Cleans up the model without deleting the model itself
     * should be called before loading a new graph to prevent id confusion
     * @param {Array} nodes Nodes to delete
     * @param {Array} edges Edges to delete
     * @param {Number} cyId
     * @param {string} user parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    deleteAll (nodes, edges, cyId, user, noHistUpdate) {

        let self = this;
        if (!noHistUpdate)
            this.updateHistory({opName: &apos;new&apos;, cyId: cyId, opTarget: &apos;model&apos;});


        edges.forEach(function (edge) {
            self.deleteModelEdge(edge.id(), cyId,  user, noHistUpdate);
        });

        nodes.forEach(function (node) {
            self.deleteModelNode(node.id(), cyId, user, noHistUpdate);
        });

    }


    /**
     * Returns the model nodes and edges as a json object
     * @param {Number} cyId Newt tab id
     * @returns {Object} Model as a json object of nodes and edges
     */
    getJsonFromModel (cyId) {

        let cyPathStr = this.getModelCyPathStr(cyId);
        let nodes = this.model.get(cyPathStr +&apos;.nodes&apos;);

        if (nodes == null)
            return null;

        let edges = this.model.get(cyPathStr +&apos;.edges&apos;);

        let jsonNodes = [];
        let jsonEdges = [];


        for (let att in nodes) {

            if (nodes.hasOwnProperty(att)) {
                let node = nodes[att];
                let jsonNode = {
                    data: node.data
                };

                jsonNodes.push(jsonNode);
            }
        }

        for (let att in edges) {
            if (edges.hasOwnProperty(att)) {
                let edge = edges[att];

                let jsonEdge = {
                    data: edge.data
                };

                jsonEdges.push(jsonEdge);
            }
        }

        return {nodes: jsonNodes, edges: jsonEdges};
    }

    /***
     * Takes a cytoscape node and loads it into the model
     * @param {Object} node Cytoscape node
     * @param {Number} cyId
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    initModelNode (node, cyId, user, noHistUpdate) {

        let nodePathStr = this.getModelNodePathStr(node.id(), cyId);
        let nodePath = this.model.at(nodePathStr);

        if (!noHistUpdate)
            this.updateHistory({opName: &apos;init&apos;, opTarget: &apos;element&apos;, elType: &apos;node&apos;, elId: node.id(), cyId: cyId});


        nodePath.set(&apos;id&apos;, node.id());

        // node._private.data.annotationsView = null;

        let interactionCount = nodePath.get(&apos;interactionCount&apos;);

        if (interactionCount == null) //this is not stored in cy
            this.changeModelNodeAttribute(&apos;interactionCount&apos;, node.id(), cyId,  0, user, true); //don&apos;t update history

        let data = nodePath.get(&apos;data&apos;);
        //bbox is a random data parameter to make sure all data parts are already in the model
        //if the only data parameters are id and class, it means it has just been added without initialization
        if (data != null &amp;&amp; data.bbox!=null) //it means data has been added before
            node.data(data);

        else {
            //correct the labels from PC queries
            let nodeData = node.data();
            if(nodeData == null)
                nodeData = node._private.data;


            nodeData.annotationsView = null;

            nodeData.auxunitlayouts = null;

            if(nodeData.statesandinfos) {

                for (let i = 0; i &lt; nodeData.statesandinfos.length; i++) {

                    if (nodeData.statesandinfos[i].clazz === &quot;state letiable&quot;) {
                        if (nodeData.statesandinfos[i].state.value === &quot;opthr&quot;) {
                            nodeData.statesandinfos[i].state.value = &quot;p&quot;;
                            nodeData.statesandinfos[i].state.letiable = &quot;T&quot; + nodeData.statesandinfos[i].state.letiable;
                        }
                        else if (nodeData.statesandinfos[i].state.value === &quot;opser&quot;) {
                            nodeData.statesandinfos[i].state.value = &quot;p&quot;;
                            nodeData.statesandinfos[i].state.letiable = &quot;S&quot; + nodeData.statesandinfos[i].state.letiable;
                        }
                        else if (nodeData.statesandinfos[i].state.value === &quot;optyr&quot;) {
                            nodeData.statesandinfos[i].state.value = &quot;p&quot;;
                            nodeData.statesandinfos[i].state.letiable = &quot;Y&quot; + nodeData.statesandinfos[i].state.letiable;
                        }
                    }

                }
                node._private.data.statesandinfos = nodeData.statesandinfos;
            }
            this.changeModelNodeAttribute(&apos;data&apos;, node.id(), cyId, nodeData, user, noHistUpdate);
        }

        //make this initially unselected
        //    nodePath.set(&apos;highlightColor&apos;, null);


        let pos = nodePath.get(&apos;position&apos;);

        if (pos != null)
            node.position(pos);

        else {
            let nodePosition = node.position();
            if(nodePosition == null)
                nodePosition = node._private.position;
            this.changeModelNodeAttribute(&apos;position&apos;, node.id(), cyId, nodePosition, user, noHistUpdate);
        }

        //Initializing css properties causes bypass problems!!

    }

    /**
     * Takes a cytoscape edge and loads it into the model
     * @param {Object} edge Cytoscape edge
     * @param {Number} cyId
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    initModelEdge (edge, cyId, user, noHistUpdate) {
        let edgePathStr = this.getModelEdgePathStr(edge.id(), cyId);
        let edgePath = this.model.at(edgePathStr);

        if (!noHistUpdate)
            this.updateHistory({opName: &apos;init&apos;, opTarget: &apos;element&apos;, elType: &apos;edge&apos;, elId: edge.id(), cyId: cyId});

        edgePath.set(&apos;id&apos;, edge.id());



        //make this initially unselected
        //edgePath.set(&apos;highlightColor&apos;, null);

        let data = edgePath.get(&apos;data&apos;);
        //cardinality is a random data parameter to make sure all data parts are already in the model
        //if the only data parameters are id and class, it means it has just been added without initialization
        if (data != null &amp;&amp; data.cardinality != null)
            edge.data(data);

        else {


            let edgeData = edge.data();
            if(edgeData == null)
                edgeData = edge._private.data;


            edgeData.annotationsView = null;
            //This is a workaround to handle (.) dots in mongo
            if(edgeData.siteLocSet){ //dots in Pathway Commons links are causing problems
                edgeData.siteLocSet = JSON.stringify(edgeData.siteLocSet);
            }
            if(edgeData.pcIDSet){ //same workaround
                edgeData.pcIDSet = JSON.stringify(edgeData.pcIDSet);

            }


            this.changeModelEdgeAttribute(&apos;data&apos;, edge.id(), cyId, edgeData, user, noHistUpdate);
        }

    }

    /***
     * Initializes the model with cytoscape elements
     * @param {Array} nodes cy elements
     * @param {Array} edges cy elements
     * @param {Number} cyId
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    initModel ( nodes, edges, cyId, user, noHistUpdate) {

        console.log(&quot;inited&quot;);

        nodes.forEach( (node) =&gt; {
            this.initModelNode(node, cyId, user, true);
        });

        edges.forEach( (edge) =&gt; {
            this.initModelEdge(edge, cyId, user, true);
        });


        let newModelCy = this.model.get(&apos;documents.&apos; + this.docId + &apos;.cy.&apos; + cyId );

        if (!noHistUpdate) {
            this.updateHistory({opName: &apos;init&apos;, cyId: cyId, param: newModelCy, opTarget: &apos;model&apos;});
        }

        console.log(&quot;Init model finished&quot;);
        //notifies other clients to update their cy graphs
        let cyPathStr = this.getModelCyPathStr(cyId);
        this.model.pass({user:&quot;me&quot;}).set(cyPathStr +&apos;.initTime&apos;, new Date());

    }

    /**
     * Saves the current model as prevCy
     * @param {Number} cyId
     */
    setRollbackPoint (cyId) {
        let modelCy = this.getModelCy(cyId);
        this.model.set(&apos;documents.&apos; + this.docId + &apos;.prevCy.&apos; + cyId, modelCy);
    }

    /**
     * Retuns the model cytoscape json
     * @param {Number} cyId
     * @returns {Object}
     */
    getModelCy (cyId) {
        let cyPathStr = this.getModelCyPathStr(cyId);
        return this.model.get(cyPathStr);
    }


    /**
     * This is used for undo/redo purposes only
     * @param {Number} cyId
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    mergeJsons (cyId, user, noHistUpdate) {
        let cyPathStr = this.getModelCyPathStr(cyId);
        let modelCy = this.model.get(cyPathStr);
        let prevModelCy = this.model.get(&apos;documents.&apos; + this.docId + &apos;.prevCy.&apos; + cyId); //updated at rollback point

        if (!noHistUpdate) {
            this.updateHistory({opName: &apos;merge&apos;, cyId: cyId, prevParam: prevModelCy, param: modelCy, opTarget: &apos;model&apos;});
        }

    }

    /**
     * Assigns genes to a cellular location
     * @param {Array} genes Gene names
     * @param {string} location Cellular location such as &quot;nucleus&quot;
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    addModelCellularLocation(genes, location, user, noHistUpdate) {

        let prevModelCellularLocationGenes = this.model.get(&apos;documents.&apos; + this.docId +&apos;.cellularLocations.&apos;+ location);

        this.model.pass({user:user}).set(&apos;documents.&apos; + this.docId +&apos;.cellularLocations.&apos;+ location, genes);

        if (!noHistUpdate) {
            this.updateHistory({opName: &apos;addCellularLocation&apos;, param: {location: location, genes: genes}, prevParam: {location:location, genes:prevModelCellularLocationGenes}, opTarget: &apos;model&apos;});
        }
    }

    /**
     * Removes the cellular location and anything associated with it
     * @param {string} location Cellular location such as &quot;nucleus&quot;
     * @param {string} user Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    removeModelCellularLocation(location, user, noHistUpdate) {
        this.model.pass({user:user}).remove(&apos;documents.&apos; + this.docId +&apos;.cellularLocations&apos;, location);

        if (!noHistUpdate) {
            this.updateHistory({opName: &apos;removeCellularLocation&apos;, param: null, prevParam: location, opTarget: &apos;model&apos;});
        }

    }

    /**
     * Remove gene names from cellular location
     * @param {Array} genes Gene names
     * @param {string} location Cellular location such as &quot;nucleus&quot;
     * @param {string} user  Parameter to test if the update comes from the same client
     * @param {boolean} noHistUpdate Whether this operation will be recorded in history
     */
    removeNodesFromCellularLocation(genes, location, user, noHistUpdate){
        let modelGenes = this.model.get(&apos;documents.&apos; + this.docId +&apos;.cellularLocations.&apos; + location);


        let filteredGenes = modelGenes.filter(function(val){
           return genes.indexOf(val) &lt; 0
        });

    //    reassign genes
        this.model.pass({user:user}).this.model.set(&apos;documents.&apos; + this.docId +&apos;.cellularLocations.&apos; + location, filteredGenes);

        if (!noHistUpdate) {
            this.updateHistory({opName: &apos;removeNodesFromCellularLocation&apos;, param: {location:location, genes: filteredGenes}, prevParam: {location:location, genes: modelGenes}, opTarget: &apos;model&apos;});
        }
    }

}

module.exports = ModelManager;

/**
 * Local function that returns a random hexadecimal color value
 * @returns {string} hexadecimal color code
 */
function getNewColor(){
    let oneColor = require(&apos;onecolor&apos;);

    let gR = 1.618033988749895; //golden ratio
    let h = Math.floor((Math.random() * gR * 360));//Math.floor((cInd * gR - Math.floor(cInd * gR))*360);
    let cHsl = [h, 70 + Math.random() * 30, 60 + Math.random() * 10];
    let strHsl = &apos;hsl(&apos;+cHsl[0]  +&apos;, &apos;+ cHsl[1] + &apos;%, &apos; + cHsl[2] +&apos;%)&apos;;

    return oneColor(strHsl).hex();
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
